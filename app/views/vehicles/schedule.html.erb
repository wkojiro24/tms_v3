<% content_for :title, "点検・整備計画" %>
<% content_for :section_label, "車両" %>
<% content_for :head do %>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-timeline/7.7.3/vis-timeline-graph2d.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-timeline/7.7.3/vis-timeline-graph2d.min.js"></script>
<% end %>

<div class="card shadow-sm mb-4">
  <div class="card-body d-flex flex-wrap justify-content-between align-items-center">
    <div>
      <h1 class="h4 mb-1 fw-semibold">点検・整備スケジュール</h1>
      <p class="text-muted mb-0 small">縦軸に車両、横軸に月をとったマトリクスで車検・点検の計画を可視化します。</p>
    </div>
    <%= link_to "配車情報へ", dispatch_path, class: "btn btn-outline-secondary btn-sm" %>
  </div>
</div>

<div class="card shadow-sm mb-3">
  <div class="card-body">
    <%= form_with url: maintenance_schedule_path, method: :get, local: true, class: "row g-2" do %>
      <div class="col-md-4">
        <label class="form-label small text-muted">表示開始月</label>
        <input type="month" name="start_month" value="<%= @start_month.strftime('%Y-%m') %>" class="form-control">
      </div>
      <div class="col-md-3">
        <label class="form-label small text-muted">営業所</label>
        <%= select_tag :depot, options_for_select([["すべて", ""]]+Vehicle.distinct.pluck(:depot_name).compact_blank.map { |d| [d, d] }, @schedule_depot), class: "form-select" %>
      </div>
      <div class="col-md-3">
        <label class="form-label small text-muted">車種</label>
        <%= select_tag :vehicle_type, options_for_select([["すべて", ""]]+Vehicle.distinct.pluck(:vehicle_category).compact_blank.map { |t| [t, t] }, @schedule_type), class: "form-select" %>
      </div>
      <div class="col-md-2 d-grid align-items-end">
        <button class="btn btn-primary mt-auto">更新</button>
      </div>
    <% end %>
  </div>
</div>

<div class="row g-3 align-items-stretch">
  <div class="col-lg-10">
    <div class="card shadow-sm">
      <div class="card-header bg-white d-flex justify-content-between align-items-center">
        <span class="fw-semibold">整備タイムライン</span>
        <div class="btn-group btn-group-sm timeline-view-toggle" role="group">
          <button type="button" class="btn btn-outline-secondary active" data-timeline-view="month">月</button>
          <button type="button" class="btn btn-outline-secondary" data-timeline-view="week">週</button>
          <button type="button" class="btn btn-outline-secondary" data-timeline-view="day">日</button>
        </div>
      </div>
      <div class="card-body">
        <div id="maintenance-timeline"
             data-groups="<%= raw(@timeline_groups.to_json) %>"
             data-items="<%= raw(@timeline_items.to_json) %>"
             data-range-start="<%= @start_month.strftime('%Y-%m-%d') %>"
             data-range-end="<%= @timeline_range_end.strftime('%Y-%m-%d') %>"
             data-create-url="<%= maintenance_events_path %>"
             data-event-base-url="<%= maintenance_events_path %>">
        </div>
      </div>
    </div>
  </div>
  <div class="col-lg-2">
    <div class="card shadow-sm timeline-labels-card">
      <div class="card-header bg-white fw-semibold">整備ラベル</div>
      <div class="card-body">
        <p class="text-muted small mb-2">ラベルをドラッグしてタイムラインへ投下してください。</p>
        <div id="external-labels" class="d-flex flex-column gap-2">
          <% @event_labels.each do |label| %>
            <div class="timeline-label badge bg-<%= label[:style] %> text-white"
                 draggable="true"
                 data-label="<%= label[:label] %>"
                 data-inspection-type="<%= label[:inspection_type] %>"
                 data-scope="<%= label[:inspection_scope] %>"
                 data-status="<%= label[:status] %>">
              <%= label[:label] %>
            </div>
          <% end %>
        </div>
      </div>
    </div>
  </div>
</div>

<%= javascript_tag do %>
  document.addEventListener("turbo:load", function () {
    const container = document.getElementById("maintenance-timeline")
    if (!container || typeof vis === "undefined" || container.dataset.timelineBound === "true") {
      return
    }

    let groups = []
    let items = []
    try {
      groups = JSON.parse(container.dataset.groups || "[]")
      items = JSON.parse(container.dataset.items || "[]")
    } catch (error) {
      groups = []
      items = []
    }

    console.log("maintenance schedule groups", groups)
    console.log("maintenance schedule items", items)
    const dataGroups = new vis.DataSet(groups)

    const groupTemplate = function (group) {
      const regionLine = [group.region, group.klass].filter(Boolean).join(" ")
      const meta = []
      if (group.depot) meta.push(group.depot)
      if (group.call_sign) meta.push(group.call_sign)
      if (group.vehicle_category) meta.push(group.vehicle_category)
      return `
        <div class="timeline-group">
          <div class="timeline-group__plate plate-mini mb-1">
            <div class="plate-mini__region">${regionLine}</div>
            <div class="plate-mini__body">
              <span class="plate-mini__kana">${group.kana || ""}</span>
              <span class="plate-mini__number">${group.number || group.plate}</span>
            </div>
          </div>
          <div class="timeline-group__meta">${meta.join(" / ")}</div>
        </div>
      `
    }
    const dataItems = new vis.DataSet(
      items.map((item) => {
        const mapped = { ...item }
        if (item.placeholder) {
          mapped.className = "timeline-placeholder"
          mapped.type = "background"
          mapped.selectable = false
          mapped.editable = false
        } else {
          mapped.className = `timeline-event timeline-event-${item.status || "scheduled"}`
        }
        return mapped
      })
    )

    const baseStart = new Date(container.dataset.rangeStart)
    const rangeEnd = new Date(container.dataset.rangeEnd)
    const options = {
      stack: false,
      orientation: "top",
      zoomable: false,
      horizontalScroll: true,
      moveable: true,
      selectable: true,
      multiselect: false,
      min: baseStart,
      max: rangeEnd,
      groupHeightMode: "fitRows",
      editable: {
        add: false,
        updateTime: true,
        updateGroup: true,
        remove: true
      },
      margin: { item: 20, axis: 20 },
      groupHeightMode: "fitRows",
      groupTemplate: groupTemplate
    }

    const timeline = new vis.Timeline(container, dataItems, dataGroups, options)
    const csrfToken = document.querySelector("meta[name='csrf-token']")?.content
    const createUrl = container.dataset.createUrl
    const baseUrl = container.dataset.eventBaseUrl

    const viewButtons = container.closest(".card").querySelectorAll("[data-timeline-view]")
    viewButtons.forEach((button) => {
      button.addEventListener("click", () => setView(button.dataset.timelineView, button))
    })

    function setView (type, button) {
      const start = new Date(baseStart)
      const end = new Date(start)
      let axis = { scale: "day", step: 1 }

      if (type === "day") {
        end.setDate(start.getDate() + 1)
        axis = { scale: "hour", step: 2 }
      } else if (type === "week") {
        end.setDate(start.getDate() + 7)
        axis = { scale: "day", step: 1 }
      } else {
        end.setMonth(start.getMonth() + 1)
        axis = { scale: "day", step: 2 }
      }

      timeline.setOptions({ timeAxis: axis })
      timeline.setWindow(start, end, { animation: false })
      viewButtons.forEach((btn) => btn.classList.remove("active"))
      if (button) button.classList.add("active")
    }

    setView("month", container.closest(".card").querySelector("[data-timeline-view='month']"))

    timeline.on("move", function (item, callback) {
      if (item.placeholder) {
        callback(null)
        return
      }
      persistUpdate(item).then((success) => {
        callback(success ? item : null)
      })
    })

    timeline.on("remove", function (item, callback) {
      if (item.placeholder) {
        callback(null)
        return
      }
      if (!confirm("この予定を削除しますか？")) {
        callback(null)
        return
      }
      fetch(`${baseUrl}/${item.id}`, {
        method: "DELETE",
        headers: { "X-CSRF-Token": csrfToken }
      })
        .then((response) => {
          if (response.ok) {
            callback(item)
          } else {
            alert("削除に失敗しました。")
            callback(null)
          }
        })
        .catch(() => {
          alert("削除に失敗しました。")
          callback(null)
        })
    })

    container.addEventListener("dragover", function (event) {
      event.preventDefault()
    })

    container.addEventListener("drop", function (event) {
      event.preventDefault()
      let payload
      try {
        payload = JSON.parse(event.dataTransfer.getData("text/plain"))
      } catch (error) {
        payload = null
      }
      if (!payload) return

      const props = timeline.getEventProperties(event)
      if (!props.group || !props.time) return

      createEvent(payload, props.group, props.time)
    })

    document.querySelectorAll(".timeline-label").forEach((label) => {
      label.addEventListener("dragstart", (event) => {
        const payload = {
          label: label.dataset.label,
          inspectionType: label.dataset.inspectionType,
          inspectionScope: label.dataset.scope,
          status: label.dataset.status
        }
        event.dataTransfer.setData("text/plain", JSON.stringify(payload))
      })
    })

    function createEvent (source, groupId, time) {
      const scheduledOn = new Date(time).toISOString().slice(0, 10)
      fetch(createUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRF-Token": csrfToken
        },
        body: JSON.stringify({
          vehicle_id: groupId,
          inspection_type: source.inspectionType,
          inspection_scope: source.inspectionScope,
          status: source.status,
          scheduled_on: scheduledOn
        })
      }).then(async (response) => {
        if (!response.ok) {
          const error = await response.json().catch(() => ({}))
          alert(error.error || "登録に失敗しました。")
          return
        }
        const data = await response.json()
        dataItems.add({
          id: data.id,
          group: data.vehicle_id,
          start: data.scheduled_on,
          content: data.inspection_type,
          className: `timeline-event timeline-event-${data.status}`
        })
      })
    }

    function persistUpdate (item) {
      const scheduledOn = new Date(item.start).toISOString().slice(0, 10)
      return fetch(`${baseUrl}/${item.id}`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          "X-CSRF-Token": csrfToken
        },
        body: JSON.stringify({
          scheduled_on: scheduledOn,
          vehicle_id: item.group
        })
      }).then(async (response) => {
        if (!response.ok) {
          const error = await response.json().catch(() => ({}))
          alert(error.error || "更新に失敗しました。")
          return false
        }
        return true
      }).catch(() => {
        alert("更新に失敗しました。")
        return false
      })
    }

    container.dataset.timelineBound = "true"
  })
<% end %>
